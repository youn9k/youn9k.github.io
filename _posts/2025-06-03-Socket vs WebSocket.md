---
title: "[Network]Socket vs WebSocket"
date: 2025-06-03 12:00 +0900
categories:
  - 📚 CS
  - Computer Science
tags:
  - Socket
  - WebSocket
---

## 소켓(Socket)이란?

**소켓(Socket)** 은 네트워크를 경유하는 프로세스 간 통신의 종착점.
OSI 7계층 중 응용 계층에 속하는 프로세스들은 데이터 송수신을 위해 반드시 소켓을 거쳐 전송 계층으로 데이터를 전달해야한다.
즉, 소켓은 전송 계층과 응용 프로그램 사이의 인터페이스 역할을 하며 떨어져 있는 두 호스트를 연결해준다.

소켓은 아래의 요소들을 담고 있는 하나의 파일인 것이다.
1. 프로토콜
2. 상대와 자신의 IP 주소
3. Port 번호
4. 통신 동작 진행 상태

## 소켓에 담기는 정보 심화편+ with GPT

### ✅ 소켓(Socket)의 기본 구성 정보

소켓은 단순한 ‘연결’이 아니라, **네트워크 통신을 위한 컨텍스트(Context)**입니다.
즉, 소켓을 생성하면 다음과 같은 중요한 정보들이 내부에 저장됩니다:

|**정보 항목**|**설명**|
|---|---|
|**IP 주소**|로컬 IP / 원격 IP|
|**Port 번호**|로컬 포트 / 원격 포트|
|**프로토콜**|TCP 또는 UDP|
|**소켓 타입**|스트림(SOCK_STREAM) 또는 데이터그램(SOCK_DGRAM)|
|**소켓 상태**|연결 대기 중, 연결됨, 종료됨 등|
|**파일 디스크립터**|소켓을 식별하는 정수값(리눅스에서 중요한 역할)|
|**버퍼 정보**|수신/송신 버퍼 (임시 저장 공간)|
|**옵션 값들**|SO_REUSEADDR, TCP_NODELAY 등 다양한 소켓 옵션|

이 정보들은 운영체제 커널의 소켓 구조체(struct socket, struct sock)에 저장되며, 네트워크 통신의 흐름을 관리하는 데 사용됩니다.

### 🧾 리눅스에서 소켓은 “파일”이다?

**✅ 소켓은 파일 디스크립터(File Descriptor)를 통해 다뤄진다**
- 리눅스에서 소켓은 int 형식의 **파일 디스크립터(fd)** 로 표현됩니다.
- 즉, socket()을 호출하면 open()처럼 **파일 핸들처럼 정수 값**을 반환합니다.

```c
int fd = socket(AF_INET, SOCK_STREAM, 0);
```
- fd는 마치 open("/path/to/file") 했을 때 반환되는 파일 핸들과 동일한 방식으로 사용됩니다.

### 🧠 왜 “파일처럼” 다룰까?

리눅스는 모든 것을 파일로 취급하는 철학을 따릅니다.

→ **“Everything is a file”** (파일, 디렉토리, 파이프, 소켓 등)

따라서 소켓도 다음과 같이 **파일 기반 함수**들로 제어가 가능합니다:

| **함수**                    | **설명**              |
| --------------------------- | --------------------- |
| read(fd, buf, len)          | 소켓 수신             |
| write(fd, buf, len)         | 소켓 송신             |
| close(fd)                   | 소켓 종료             |
| select() / poll() / epoll() | 파일/소켓 이벤트 감지 |

즉, **소켓도 파일처럼 읽고 쓸 수 있는 스트림 자원**으로 통일된 방식으로 취급됩니다.

### 📂 /proc, /dev, /sys에선 어떻게 보일까?

- `/proc/{PID}/fd/{n}`
→ 현재 프로세스의 n번째 파일 디스크립터가 어떤 소켓을 가리키는지 볼 수 있음

``` 
// 출력 예시
lrwx------ 1 user user 64 6월  3 14:40 3 -> socket:[123456]
```

- socket:[123456]는 커널 내부 소켓 테이블의 고유 ID입니다.
- netstat, ss, lsof -i 같은 명령어를 통해 어떤 포트가 열려 있고, 어떤 소켓이 어떤 프로세스에 열려 있는지 확인할 수 있습니다.

### 🔧 소켓 타입 요약

|**프로토콜 계열**|**소켓 타입**|**설명**|
|---|---|---|
|AF_INET (IPv4)|SOCK_STREAM|TCP 연결용|
|AF_INET (IPv4)|SOCK_DGRAM|UDP 패킷용|
|AF_UNIX (Unix 도메인)|SOCK_STREAM|프로세스 간 통신용 (로컬)|
|AF_UNIX|SOCK_DGRAM|비연결형 로컬 메시지 전송|


## 소켓의 종류

소켓은 프로토콜에 따라 두가지로 나뉜다.

1. **스트림 소켓**
    - **TCP** 방식을 사용하는 **연결지향 방식** 의 소켓
    - 송수신자의 연결을 보장하여 **신뢰성있는 데이터 송수신**이 가능
    - 데이터의 순서 보장
    - 소량의 데이터보다 대량 데이터 전송에 적합
    - 점대점 연결
    
2. **데이터그램 소켓**
    - **UDP** 방식을 사용하는 **비연결 방식**의 소켓
    - 데이터의 순서와 **신뢰성을 보장하기 어려움**
    - 점대점 뿐만 아니라 일대다 연결도 가능
    - accept 과정 없이 소켓 생성 후 바로 데이터 송수신

## 스트림 소켓(TCP) 통신 흐름

![image](https://gist.github.com/user-attachments/assets/18c9a99f-0959-47ed-b0de-0f466e78f7f2)

서버는 아래와 같은 흐름으로 진행됩니다.

 1. 소켓 생성
 2. 바인딩(ip, port 번호 설정)
3. listen()으로 클라이언트 요청에 대기열을 만들어 몇개의 클라이언트를 대기시킬지 결정  
4. accept(): 소켓 연결 요청이 오면, 3way-handshake 과정이 진행되고 클라이언트와 연결
5. 데이터 송수신
6. 소켓 닫기

클라이언트는 아래와 같은 흐름으로 진행됩니다.

1. 소켓 생성
2. listen 상태인 서버의 소켓에 연결 요청
3. 3way-handshake 과정이 진행되고, 완료되면 소켓 상태가 Established로 바뀜
4. 데이터 송수신
5. 소켓 닫기

**스트림 소켓(TCP) 통신 흐름에서 가장 중요한 것은 `accept()`**

## WebSocket이란?

WebSocket은 웹 브라우저 환경에서 서버와 **지속적인 양방향 통신** 을 할 수 있도록 하기 위해 만들어진 프로토콜입니다.

기존 HTTP 방식으로는 실시간 통신이 비효율적이었기 때문에, WebSocket은 **TCP 위에 경량화된 통신 프레임 구조를 얹어** 더 효율적으로 통신할 수 있게 합니다.

## WebSocket 등장 배경

기존 HTTP는 요청-응답 구조만을 가지고 있었습니다.
따라서 웹 브라우저가 서버로부터 실시간으로 데이터를 받고 싶다면, 지속적으로 새 요청을 보내거나 *long poling 이라는 우회 방식을 사용해야 했습니다.

> Polling과 비슷하게 일정 주기마다 요청을 보내지만 서버가 응답을 바로 전달하지 않고 특정 이벤트나 타임아웃이 발생했을 때 응답을 전달하는 방식

이는 *네트워크 오버헤드가 발생하고 실시간 통신에 적합한 구조는 아니었습니다.

> 불필요한 HTTP 헤더 등

하지만 웹 브라우저는 보안을 위해 임의의 TCP 포트로 직접 소켓을 연결할 수 없습니다. 따라서 브라우저에서 사용할 수 있는 안전한 TCP 소켓이 필요했고, WebSocket이 등장하게 되었습니다. 

## WebSocket 통신 흐름

WebSocket은 HTTP를 통해 연결을 수립하고, 연결된 다음부턴 TCP 소켓을 통해 실시간 양방향 통신을 지원합니다.

![](/assets/img/post/2025/044.png)


### 클라이언트 -> 서버

웹소켓의 통신 요청은 HTTP 버전 1.1 이상, GET 메소드를 사용해야 함.

```
GET /chat HTTP/1.1  
Host: example.com  
Upgrade: websocket  
Connection: Upgrade  
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==  
Sec-WebSocket-Version: 13
```

### 서버 -> 클라이언트

101은 HTTP에서 WS로 프로토콜 전환이 승인되었다는 응답코드.

```
HTTP/1.1 101 Switching Protocols  
Upgrade: websocket  
Connection: Upgrade  
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

## WebSocket 통신 방식

WebSocket 연결이 수립되면, 이후 모든 데이터는 **프레임 단위(Frame)**로 전송됩니다.

프레임은 WebSocket 프로토콜이 정의한 최소 단위로, 각각의 메시지를 작은 조각으로 나누어 전송하고, 다시 합쳐 하나의 메시지로 만듭니다.

프레임은 작은 헤더 + payload 로 구성되어 있습니다.

![](/assets/img/post/2025/045.png)


### 주요 필드 

|**필드**|**설명**|
|---|---|
|FIN|마지막 프레임 여부 (1이면 메시지 끝)|
|RSV1~3|확장용 예약 비트 (보통 0)|
|opcode|데이터의 유형 (텍스트, 바이너리, 제어 메시지 등)|
|Mask|클라이언트 → 서버 전송 시 항상 1 (데이터 마스킹됨)|
|Payload length|데이터 길이 (7비트, 16비트, 64비트로 확장 가능)|
|Masking key|실제 데이터의 XOR 마스킹 키 (클라이언트 → 서버일 때만 존재)|
|Payload data|실제 전송되는 데이터 (텍스트/바이너리 등)|


### 프레임 타입 (opcode)

| **opcode** | **종류**         | **설명**                           |
| ---------- | ---------------- | ---------------------------------- |
| 0x0        | Continuation     | 이어지는 메시지 조각               |
| 0x1        | Text             | UTF-8 텍스트 데이터                |
| 0x2        | Binary           | 바이너리 데이터                    |
| 0x8        | Connection Close | 연결 종료                          |
| 0x9        | Ping             | 서버 상태 체크 (클라이언트가 보냄) |
| 0xA        | Pong             | Ping 응답 (서버가 보냄)            |





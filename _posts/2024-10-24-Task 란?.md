---
title: "[Swift]Task ë€?"
date: 2024-10-24 12:00 +0900
categories:
  - ğŸ iOS
  - Swift
tags:
  - Swift
  - Task
  - Concurrency
---

Swift6ê°€ ë‚˜ì˜¤ë©´ì„œ ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ë™ì‹œì„± ë¬¸ì œë¥¼ ê°•í•˜ê²Œ ì¡ë”ë¼êµ¬ìš”. ê·¸ë˜ì„œ ë” ì´ìƒ Swift Concurrency ê³µë¶€ë¥¼ ë¯¸ë£° ìˆ˜ ì—†ê² ë‹¤ ì‹¶ì–´ ì°¨ê·¼ì°¨ê·¼ í•™ìŠµí•´ë³´ë ¤ê³  í•©ë‹ˆë‹¤. 
ì˜¤ëŠ˜ì€ Taskì— ëŒ€í•´ì„œ ê³µì‹ë¬¸ì„œì™€ í•¨ê»˜ ì•Œì•„ë³¼ê±°ì—ìš”.

Task ê³µì‹ ë¬¸ì„œ: [https://developer.apple.com/documentation/swift/task](https://developer.apple.com/documentation/swift/task)

## Task ë€?

ë¹„ë™ê¸°ì ì¸ ì‘ì—…ì˜ ë‹¨ìœ„(A unit of asyncchronous work) ì…ë‹ˆë‹¤.

```swift
@frozen 
struct Task<Success, Failure> where Success : Sendable, Failure : Error
```

## Overview ê°œìš”

ì‘ì—…(Task)ëŠ” ìƒì„± ì§í›„ì— ë°”ë¡œ ì‹¤í–‰ë  ìˆ˜ ìˆìœ¼ë©°, ëª…ì‹œì ìœ¼ë¡œ ì‹œì‘í•˜ê±°ë‚˜ ì˜ˆì•½í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.
> Tasks can start running immediately after creation; you donâ€™t explicitly start or schedule them.

> ğŸ¤” Task.ì‹¤í–‰() ê³¼ ê°™ì´ ëª…ì‹œì ìœ¼ë¡œ ì‹¤í–‰í•˜ì§€ ì•Šì•„ë„ Task ë¥¼ ìƒì„±í•˜ë©´ ë°”ë¡œ ì‘ì—…ì´ ì‹¤í–‰ëœë‹¤ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.

ì‘ì—…ì„ ìƒì„±í•œ í›„ì—ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ì‘ì—…ê³¼ ìƒí˜¸ì‘ìš©í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê±°ë‚˜ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> After creating a task, you use the instance to interact with it â€” for example, to wait for it to complete or to cancel it. Itâ€™s not a programming error to discard a reference to a task without waiting for that task to finish or canceling it.

> ğŸ¤” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•´ ë³€ìˆ˜ì— ë‹´ì•„ì„œ í•´ë‹¹ taskì™€ ìƒí˜¸ì‘ìš©í•˜ë©´ ëœë‹¤ëŠ” ê²ƒ ê°™ë„¤ìš”

ì‘ì—…ì´ ì™„ë£Œë˜ê±°ë‚˜ ì·¨ì†Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ì‘ì—…ì— ëŒ€í•´ ì°¸ì¡°ë¥¼ ë²„ë¦¬ëŠ” ê²ƒì€(discard)ì€
 í”„ë¡œê·¸ë˜ë° ì˜¤ë¥˜ê°€ ì•„ë‹™ë‹ˆë‹¤. 
 > Itâ€™s not a programming error to discard a reference to a task without waiting for that task to finish or canceling it.
 
 ì‘ì—…ì€ ì°¸ì¡° ìœ ì§€ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ì‹¤í–‰ë©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì‘ì—…ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ë²„ë¦¬ë©´(discard) í•´ë‹¹ ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ê±°ë‚˜ ì‘ì—…ì„ ì·¨ì†Œí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ í¬ê¸°í•˜ê²Œ ë©ë‹ˆë‹¤.
> A task runs regardless of whether you keep a reference to it. However, if you discard the reference to a task, you give up the ability to wait for that taskâ€™s result or cancel the task.

> ğŸ¤” ì¤‘ìš”í•œ ê°œë…ì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤. í•´ë‹¹ taskì˜ ì°¸ì¡°ê°€ ì‚¬ë¼ì ¸ë„ ì‘ì—…ì€ ê³„ì† ì‹¤í–‰ëœë‹¤ë„¤ìš”.

ë¶„ë¦¬ëœ ì‘ì—…(detached task)ì´ê±°ë‚˜ í•˜ìœ„ ì‘ì—…(child task)ì¼ ìˆ˜ ìˆëŠ” í˜„ì¬ ì‘ì—…(current task) ì— ëŒ€í•œ ëª…ë ¹(operations)ì„ ì§€ì›í•˜ê¸° ìœ„í•´, TaskëŠ” `yeild()`ì™€ ê°™ì€ í´ë˜ìŠ¤ ë©”ì†Œë“œë„ ì œê³µí•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ë©”ì†Œë“œëŠ” ë¹„ë™ê¸°ì ì´ë¯€ë¡œ í•­ìƒ ê¸°ì¡´ ì‘ì—…(existing task)ì˜ ì¼ë¶€ë¡œ í˜¸ì¶œë©ë‹ˆë‹¤.
> To support operations on the current task, which can be either a detached task or child task,Â `Task`Â also exposes class methods likeÂ `yield()`. Because these methods are asynchronous, theyâ€™re always invoked as part of an existing task.

> ğŸ¤” ì—„ ì´ê²Œ ë¬´ìŠ¨ ë§ì¼ê¹Œìš”. yield() ê°€ ë¬´ìŠ¨ ë©”ì†Œë“ ì§€ ì•Œë©´ ì´í•´ê°€ ë ê¹Œìš”?ã…œã…œ

ì‘ì—…ì˜ ì¼ë¶€(part of the task)ë¡œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œë§Œ í•´ë‹¹ ì‘ì—…(task)ê³¼ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
í˜„ì¬ ì‘ì—…(current task)ì™€ ìƒí˜¸ì‘ìš©í•˜ë ¤ë©´, Taskì˜ static ë©”ì†Œë“œ ì¤‘ í•˜ë‚˜ë¥¼ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.
> Only code thatâ€™s running as part of the task can interact with that task. To interact with the current task, you call one of the static methods onÂ `Task`.

> ğŸ¤” current taskëŠ” ë”°ë¡œ ë³€ìˆ˜ì— ë‹´ê²¨ìˆì§€ ì•Šì„í…Œë‹ˆ ì°¸ì¡°ë¥¼ ëª¨ë¥¼í…Œê³  ê·¸ë˜ì„œ Taskì˜ static ë©”ì†Œë“œë¡œ ìƒí˜¸ì‘ìš©í•´ì•¼í•œë‹¤ëŠ”ê±°ê² ì£ ?

ì‘ì—…ì˜ ì‹¤í–‰(tasks execution)ì€ ì‘ì—…ì´ ì‹¤í–‰ëœ(where the task ran) ì¼ë ¨ì˜ ê¸°ê°„(series of period)ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ê° ê¸°ê°„ì€ ì¼ì‹œ ì¤‘ë‹¨ ì‹œì (suspension point) ë˜ëŠ” ì‘ì—… ì™„ë£Œ(completion)ì‹œ ì¢…ë£Œë©ë‹ˆë‹¤.
> A taskâ€™s execution can be seen as a series of periods where the task ran. Each such period ends at a suspension point or the completion of the task.

> ğŸ¤” ì´ê²Œ ë¬´ìŠ¨ ë§ì¼ê¹Œìš”.. í 

ì´ëŸ¬í•œ ì‹¤í–‰ ê¸°ê°„ì€ PartialAsyncTaskì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ í‘œì‹œë©ë‹ˆë‹¤. ì‚¬ìš©ì ì •ì˜ ì‹¤í–‰ì(custom executor)ë¥¼ êµ¬í˜„í•˜ì§€ ì•ŠëŠ” í•œ, ë¶€ë¶„ ì‘ì—…(partial tasks)ê³¼ ì§ì ‘ ìƒí˜¸ ì‘ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
> These periods of execution are represented by instances ofÂ `PartialAsyncTask`. Unless youâ€™re implementing a custom executor, you donâ€™t directly interact with partial tasks.

> ğŸ¤” PartialAsyncTaskë¥¼ ì°¾ì•„ë³´ë‹ˆ UnownedJobì˜ typealias ë˜ë°, Task ë‚´ ë¶€ë¶„ ì‘ì—…ì— ëŒ€í•´ ì§ì ‘ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ì—†ë‹¤ëŠ” ëœ»ì¼ê¹Œìš”?

## Task Cancellation ì‘ì—… ì·¨ì†Œ

ì‘ì—…(Task)ì€ ì·¨ì†Œë¥¼ ê°€ë¦¬í‚¤ê¸° ìœ„í•œ ê³µìœ ëœ ë©”ì»¤ë‹ˆì¦˜(shared mechanism)ì´ í¬í•¨ë˜ì–´ ìˆì§€ë§Œ, ì·¨ì†Œë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ê³µìœ ëœ êµ¬í˜„(shared implementation)ì€ í¬í•¨ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.

> Tasks include a shared mechanism for indicating cancellation, but not a shared implementation for how to handle cancellation.

ì‘ì—…ì—ì„œ(in the task) ìˆ˜í–‰ ì¤‘ì¸ ì‘ì—…(work)ì— ë”°ë¼ í•´ë‹¹ ì‘ì—…ì„ ì¤‘ë‹¨í•˜ëŠ” ì˜¬ë°”ë¥¸ ë°©ë²•ì´ ë‹¤ë¦…ë‹ˆë‹¤.

> Depending on the work youâ€™re doing in the task, the correct way to stop that work varies.

ë§ˆì°¬ê°€ì§€ë¡œ, ì‘ì—…ì˜ ì¼ë¶€ë¡œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œëŠ” ì¤‘ë‹¨ì´ ì ì ˆí•  ë•Œë§ˆë‹¤ ì·¨ì†Œë¥¼ í™•ì¸í•˜ëŠ” ì±…ì„ì´ ìˆìŠµë‹ˆë‹¤.

> Likewise, itâ€™s the responsibility of the code running as part of the task to check for cancellation whenever stopping is appropriate.

ì—¬ëŸ¬ ë¶€ë¶„(multiple pieces)ì´ í¬í•¨ëœ ì¥ê¸° ì‘ì—…(long-task)ì—ì„œëŠ” ì—¬ëŸ¬ ì§€ì ì—ì„œ ì·¨ì†Œë¥¼ í™•ì¸í•˜ê³  ê° ì§€ì ì—ì„œ ì·¨ì†Œë¥¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬í•´ì•¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

> In a long-task that includes multiple pieces, you might need to check for cancellation at several points, and handle cancellation differently at each point.

> ğŸ¤” ìœ„ì˜ 4 ë¬¸ì¥ì„ ì´í•´í•´ë³´ë©´, task ì•ˆì— ì—¬ëŸ¬ ê°œì˜ workê°€ ìˆì„ ìˆ˜ ìˆëŠ”ë° work ë§ˆë‹¤ ì˜¬ë°”ë¥¸ ì¤‘ë‹¨ ë°©ë²•ì´ ë‹¤ë¥´ë‹ˆ ì·¨ì†Œì— ëŒ€í•œ êµ¬í˜„ì€ ì§ì ‘í•´ì•¼í•œë‹¤ëŠ” ëœ»ìœ¼ë¡œ ë“¤ë¦¬ë„¤ìš”.

ì‘ì—…(work)ì„ ì¤‘ë‹¨í•˜ê¸° ìœ„í•´ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚¤ê¸°ë§Œ í•˜ë©´ ë˜ëŠ” ê²½ìš°, ì·¨ì†Œë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ Task.checkCancellation() í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. 
ì·¨ì†Œì— ëŒ€í•œ ë‹¤ë¥¸ ì‘ë‹µì—ëŠ” ì§€ê¸ˆê¹Œì§€ ì™„ë£Œëœ ì‘ì—…ì„ ë°˜í™˜(returning the work), ë¹ˆ ê²°ê³¼ ë°˜í™˜(returning an empty result) ë˜ëŠ” nil ë°˜í™˜(returning nil)ì´ í¬í•¨ë©ë‹ˆë‹¤.

> If you only need to throw an error to stop the work, call theÂ `Task.checkCancellation()`Â function to check for cancellation. Other responses to cancellation include returning the work completed so far, returning an empty result, or returningÂ `nil`.

ì·¨ì†ŒëŠ” ìˆœì „íˆ Boolean ìƒíƒœì…ë‹ˆë‹¤. ì·¨ì†Œ ì´ìœ ì™€ ê°™ì€ ì¶”ê°€ ì •ë³´ë¥¼ í¬í•¨í•  ë°©ë²•ì€ ì—†ìŠµë‹ˆë‹¤.
ì´ëŠ” ì—¬ëŸ¬ ê°€ì§€ ì´ìœ ë¡œ ì‘ì—…ì´ ì·¨ì†Œë  ìˆ˜ ìˆìœ¼ë©° ì·¨ì†Œ í”„ë¡œì„¸ìŠ¤ ì¤‘ì— ì¶”ê°€ ì´ìœ ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤ëŠ” ì‚¬ì‹¤ì„ ë°˜ì˜í•©ë‹ˆë‹¤.

> Cancellation is a purely Boolean state; thereâ€™s no way to include additional information like the reason for cancellation. This reflects the fact that a task can be canceled for many reasons, and additional reasons can accrue during the cancellation process.

> ğŸ¤” ìœ„ì˜ ë‘ ë¬¸ì¥ì€ ì·¨ì†Œí•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ë‚´ìš©ì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤.


### Task closure lifetime ì‘ì—… í´ë¡œì €ì˜ ìˆ˜ëª…

ì‘ì—…(Task)ì€ ì£¼ì–´ì§„ ì‘ì—…(given task)ì— ì˜í•´ ì‹¤í–‰ë  ì½”ë“œê°€ í¬í•¨ëœ í´ë¡œì €ë¥¼ ì „ë‹¬í•¨ìœ¼ë¡œì¨ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.
> Tasks are initialized by passing a closure containing the code that will be executed by a given task.

ì´ ì½”ë“œê°€ ì™„ë£Œ(run to completion)ëœ í›„, ì‘ì—…(Task)ì€ ì‹¤íŒ¨(failure) ë˜ëŠ” ê²°ê³¼ ê°’(result value)ìœ¼ë¡œ ì™„ë£Œë˜ë©°, ì´ í´ë¡œì €ëŠ” ì¦‰ì‹œ í•´ì œë©ë‹ˆë‹¤.
> After this code has run to completion, the task has completed, resulting in either a failure or result value, this closure is eagerly released.

ì‘ì—… ê°ì²´(task object)ë¥¼ ìœ ì§€í•œë‹¤ê³  í•´ì„œ í´ë¡œì €ê°€ ë¬´ê¸°í•œ ìœ ì§€(indefinitely retain)ë˜ëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. ì‘ì—…(Task)ì´ ì™„ë£Œëœ í›„ ì‘ì—…(Task)ì´ ë³´ìœ í•œ ëª¨ë“  ì°¸ì¡°ê°€ í•´ì œë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ì‘ì—…(Task)ì€ ë“œë¬¼ê²Œ ì•½í•œ ì°¸ì¡°ë¥¼ ìº¡ì³í•  í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.(tasks rearely need to capture weak references to values)
> Retaining a task object doesnâ€™t indefinitely retain the closure, because any references that a task holds are released after the task completes. Consequently, tasks rarely need to capture weak references to values.

ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì—ì„œëŠ” ì•¡í„°ë¥¼ ì•½í•œ ê²ƒìœ¼ë¡œ ìº¡ì²˜í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ì‘ì—…ì´ ì™„ë£Œë˜ë©´ ì•¡í„° ì°¸ì¡°ë¥¼ ë†“ì•„ íƒœìŠ¤í¬ì™€ ì´ë¥¼ ë³´ìœ í•œ ì•¡í„° ì‚¬ì´ì˜ ì°¸ì¡° ìˆœí™˜ì´ ê¹¨ì§€ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
> For example, in the following snippet of code it is not necessary to capture the actor asÂ `weak`, because as the task completes itâ€™ll let go of the actor reference, breaking the reference cycle between the Task and the actor holding it.

```swift
struct Work: Sendable {}

actor Worker {
    var work: Task<Void, Never>?
    var result: Work?

    deinit {
        // ì‘ì—…(task)ì´ ì—¬ì „íˆ ìœ ì§€ë˜ê³  ìˆë”ë¼ë„,
        // ê·¸ê²ƒì´ ì™„ë£Œë˜ë©´ ì•¡í„°ì™€ ì°¸ì¡° ì‚¬ì´í´ì„ ìœ ë°œí•˜ì§€ ì•ŠìŒ
        print("deinit actor")
    }

    func start() {
        work = Task {
            print("start task work")
            try? await Task.sleep(for: .seconds(3))
            self.result = Work() // self ìº¡ì³
            print("completed task work")
            // ì‘ì—…(task)ì´ ëë‚˜ë©´ ì°¸ì¡°ê°€ í•´ì œë¨
        }
        // ì‘ì—…(task)ì— ëŒ€í•œ ê°•í•œ ì°¸ì¡°ë¥¼ ìœ ì§€í•¨
    }
}
```

ì´ë ‡ê²Œ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.

```swift
await Worker().start()
```

ì•¡í„°ëŠ” start() ë©”ì„œë“œì˜ self ì‚¬ìš©ì— ì˜í•´ì„œë§Œ ìœ ì§€ë˜ë©° êµ¬ì¡°í™”ë˜ì§€ ì•Šì€ ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  start ë©”ì„œë“œê°€ ì¦‰ì‹œ ë°˜í™˜ëœë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”. ì‘ì—…ì´ ì™„ë£Œë˜ê³  í•´ë‹¹ í´ë¡œì €ê°€ ì‚­ì œë˜ë©´ ì•¡í„°ì— ëŒ€í•œ ê°•ë ¥í•œ ì°¸ì¡°ë„ í•´ì œë˜ì–´ ì•¡í„°ê°€ ì˜ˆìƒëŒ€ë¡œ ì´ˆê¸°í™”ë¥¼ í•´ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì•¡í„°ëŠ” start() ë©”ì„œë“œì˜ self ë¡œì„œë§Œ ì°¸ì¡°ê°€ ìœ ì§€ë˜ë©°, start ë©”ì†Œë“œëŠ” êµ¬ì¡°í™”ë˜ì§€ ì•Šì€ ì‘ì—…(Task)ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ì¦‰ì‹œ ë¦¬í„´í•©ë‹ˆë‹¤.
ì‘ì—…(Task)ì´ ì™„ë£Œ(completed)ë˜ê³  í•´ë‹¹ í´ë¡œì €ê°€ íŒŒê´´(destroyed)ë˜ë©´, ì•¡í„°ì— ëŒ€í•œ ê°•í•œ ì°¸ì¡°ë„ í•´ì œë˜ì–´ ì•¡í„°ê°€ ì˜ˆìƒëŒ€ë¡œ í•´ì œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> Note that the actor is only retained by the start() methodâ€™s use ofÂ `self`, and that the start method immediately returns, without waiting for the unstructuredÂ `Task`Â to finish. Once the task is completed and its closure is destroyed, the strong reference to the actor is also released allowing the actor to deinitialize as expected.

ë”°ë¼ì„œ ìœ„ í˜¸ì¶œì˜ ê²°ê³¼ëŠ” ì¼ê´€ë˜ê²Œ ë‹¤ìŒê³¼ ê°™ì´ ì¶œë ¥ë©ë‹ˆë‹¤.
> Therefore, the above call will consistently result in the following output:

```swift
start task work
completed task work
deinit actor
```

> ğŸ¤” task ë¸”ëŸ­ ë‚´ì˜ self ëŠ” ê°•í•œì°¸ì¡°ê°€ ë°œìƒí•´ ì‘ì—…(task)ì´ ì™„ë£Œë˜ê¸° ì „ê¹Œì§„ selfê°€ deinitë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ í•„ìš”í•œ ê²½ìš° weak selfë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ë°, ìì„¸í•œ ë‚´ìš©ì€ [task ë‚´ì—ì„œ weak selfë¥¼ ë¶™ì—¬ì•¼ í•˜ëŠ” ì´ìœ ](https://youngkdevlog.tistory.com/104) ì´ ë‚´ìš©ì„ ë³´ë©´ ì°¸ê³ ê°€ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤ !